# Development Guidelines for Cursor Agents

This document is designed to clarify on what patterns current match the intended architecture. When suggesting new code these patterns should be replicated as close as possible, but should not be considered entirely dogmatic.

If in the process of building a new feature an alternative pattern is worth considering we should still explore it and in the case we decide to proceed you should recommend updates to this file that better match the new approach

## Core Principles

- **Use native Obsidian Plugin API as much as possible** - Always check `node_modules/obsidian/obsidian.d.ts` for complete type definitions and prefer the use of these over building net new. When building new prefer to extend existing Obsidian classes when possible.
- **Attempt to match the look and feel of Obsidian** - Prefer to leverage existing Obsidian components, CSS classes, and variables. Limit the amount of additional CSS created. When creating new UI elements attempt to style in a manner that matches the existing UI
- **Desktop-only plugin** - This plugin is designated as desktop-only (`isDesktopOnly: true` in manifest.json). Node modules can be used freely without mobile compatibility concerns.

## Conversation Workflow

Each development conversation follows a structured goal-oriented process:

### 1. Goal Setting
- User defines the functionality goal for the conversation
- AI proposes a concise set of implementation steps
- Discussion until approach is aligned

### 2. Step-by-Step Implementation
For each step, follow this cycle:

1. **Propose** - AI suggests specific changes for the current step
2. **Discuss** - Back and forth until approach is agreed.  User will ask for clarifications and define criteria.  Agent should provide confimation of updates and answer questions.  Agent should only produce full updated plan when prompted to do so.
3. **Implement** - User instructs AI to implement (switch to agent mode if needed)
4. **Test** - AI prompts user to test; work through bugs/adjustments
5. **Commit** - Once satisfied, commit the changes with appropriate semantic prefix
6. **Repeat** - Proceed to next step

### Workflow Rules
- Keep step proposals focused and concise
- Don't proceed to detailing any steps until explicitly instructed
- Don't proceed to implementation until explicitly instructed
- Always prompt for testing after implementation
- Commit after each completed step, not in bulk at the end
- **Important!** If at any point the agree upon approach is determined not to work stop implementing. Explain the issue and ask how we should proceed

## CSS and Styling Guidelines

- **Always define styles in CSS files** - Never use inline styles or JavaScript-based styling. All CSS should live in dedicated `.css` files (e.g., `src/styles.css`)
- **Default to Obsidian CSS variables** - Always use Obsidian's built-in CSS variables (e.g., `--background-primary`, `--text-normal`, `--interactive-accent`) unless explicitly required to create custom values. This ensures theme compatibility and consistent appearance.
- **Prefer Obsidian's existing CSS classes** - Before creating new classes, check if Obsidian provides existing classes that achieve the desired styling
- **Minimize custom CSS** - Only add custom styles when Obsidian's built-in classes and variables cannot achieve the desired result
- **Document custom CSS variables** - If custom CSS variables are necessary, document why and consider if they should derive from Obsidian variables

## File Size and Organization

- **Keep files under 300 lines** - Files should ideally stay under 300 lines of code. When a file approaches or exceeds this threshold, consider breaking it apart.
- **Single responsibility per file** - Each file should have one clear purpose. When files grow large, look for opportunities to extract:
  - **Utility functions** → Move to a dedicated `utils/` directory
  - **Type definitions** → Extract to `types.ts` or a `types/` directory
  - **Constants and configuration** → Move to a `constants.ts` file
  - **UI components** → Each component in its own file within a `components/` directory
  - **Event handlers** → Group related handlers in dedicated files
  - **Data processing logic** → Separate from UI code into service files
- **Suggest refactoring proactively** - When adding code that would push a file over 300 lines, suggest how to reorganize before implementing
- **Use index files for directories** - When creating directories with multiple related files, use `index.ts` to re-export for cleaner imports

## Development Context

**Single User Environment**: This plugin is currently used by only one developer. Breaking changes, experimental approaches, and direct migrations are acceptable since:

- Git rollback is always available for recovery
- No external users to impact with breaking changes
- Rapid iteration and testing is preferred over extensive safety measures
- The developer can handle debugging and fixing issues directly

When suggesting approaches, prefer:

- Direct implementation over overly cautious phased approaches
- "Move fast and fix issues" over "prevent all possible issues"
- Testing new approaches quickly rather than extensive planning
- Assuming the developer can debug and resolve problems

## Git Commit Conventions

- **Use semantic commit prefixes** for all commits:
  - `feat:` - New features
  - `fix:` - Bug fixes
  - `chore:` - Maintenance tasks, dependency updates, configuration
  - `docs:` - Documentation changes
  - `refactor:` - Code restructuring without changing behavior
  - `style:` - Code style/formatting changes
  - `test:` - Adding or updating tests
- Keep the first line under 72 characters
- Use the body for additional context when needed

## Pre-Commit Review Checklist

When the user requests to "commit" or "prepare to commit", perform a comprehensive review of all uncommitted changes before proceeding. Review all modified, added, and deleted files in the working directory and staging area.

### Review Process

1. **Examine all uncommitted changes** - Review git status and read all modified/new files
2. **Run linter** - Execute linter to check for code quality issues, formatting problems, and potential errors
3. **Evaluate against checklist** - Systematically check each item below
4. **Present findings** - Provide a concise, high-level list of considerations (not detailed fixes)
5. **Wait for user decision** - Do not proceed with commit until user confirms or addresses items

### Review Checklist

For each uncommitted change, evaluate:

#### Architecture and Design
- **Alternate approaches** - Are there simpler or more maintainable architectural patterns that could achieve the same functionality? Consider:
  - Could existing Obsidian APIs or classes be leveraged instead?
  - Are we following established patterns in the codebase?
  - Would a different service/component structure be cleaner?

#### Code Quality
- **Cleanup opportunities** - Look for:
  - Unused imports, variables, or functions
  - Commented-out code that should be removed
  - Temporary debugging code (console.logs, etc.)
  - Dead code paths

- **Complexity reduction** - Identify:
  - Overly complex functions that could be simplified
  - Nested conditionals that could be flattened
  - Long parameter lists that could use objects
  - Functions doing too many things (violating single responsibility)

- **Code consolidation** - Find:
  - Duplicate logic that could be extracted to shared utilities
  - Similar functions that could be unified with parameters
  - Repeated patterns that could become reusable components
  - Redundant type definitions or constants

#### Component Lifecycle
- **Proper lifecycle management** - Verify:
  - Event handlers are registered via `registerEvent()` for automatic cleanup
  - Commands are registered via `addCommand()` for automatic cleanup
  - DOM elements are properly removed when components are destroyed
  - Subscriptions/listeners are unsubscribed on cleanup
  - Resources (file watchers, timers, etc.) are properly released

#### Styling Compliance
- **CSS file organization** - Check:
  - All styles are in dedicated `.css` files (no inline styles)
  - No JavaScript-based styling (e.g., `element.style.property = value`)
  - CSS files are appropriately located (component-level vs global)

- **Obsidian CSS variables** - Verify:
  - Obsidian CSS variables are used wherever possible (e.g., `--background-primary`, `--text-normal`, `--interactive-accent`)
  - Custom CSS variables are only used when Obsidian variables cannot achieve the result
  - Custom variables derive from Obsidian variables when possible
  - Obsidian's existing CSS classes are leveraged before creating new ones

#### File Organization
- **File size** - Check if any files exceed 300 lines and suggest extraction opportunities
- **Single responsibility** - Verify each file has a clear, single purpose
- **Directory structure** - Ensure files are in appropriate directories per the organization guidelines

#### Documentation
- **README updates** - Determine if changes require README.md updates:
  - New features or functionality → Update Features/Usage sections
  - User-facing behavior changes → Update Usage/Configuration sections
  - New commands or settings → Document in appropriate sections
  - Breaking changes → Update with migration notes if applicable

#### Code Quality Tools
- **Linter results** - Review linter output for:
  - Code quality issues (unused variables, unreachable code, etc.)
  - Formatting inconsistencies
  - Type errors or warnings
  - Potential bugs or anti-patterns
  - All linter errors should be resolved before committing

### Output Format

Present findings as a concise, bulleted list organized by category. Each item should be:
- **High-level** - Focus on "what" to consider, not detailed "how" to fix
- **Actionable** - Clear enough for the user to decide if it needs attention
- **Prioritized** - List more important items first

Example format:
```
## Pre-Commit Review Findings

### Architecture
- Consider extracting [specific pattern] to align with [existing pattern]

### Code Quality
- Remove unused [specific items]
- Simplify [specific function] - currently handles [multiple concerns]

### Lifecycle
- [Component] may need explicit cleanup for [resource type]

### Styling
- [File] uses inline styles that should move to CSS
- [Component] could use Obsidian variable `--variable-name` instead of custom value

### Documentation
- README should be updated to document [new feature/change]

### Linter
- [File] has [specific linter error/warning] that should be resolved
```

### Workflow Integration

This review should occur:
- When user explicitly requests "commit" or "prepare to commit"
- Before the final commit in the step-by-step workflow (step 5)
- After testing is complete and user is satisfied with functionality

The review does not block commits - it provides information for the user to decide whether to address items now or defer them.

## Additional Requirements and Conventions

- All public methods should have JS docs
- Methods should be explicit in their purpose and avoid side effects that aren't obvious based on the name
- Event handling function should live directly in the registerEvents callback
- file.path is the only reliable unique identifier
- if file.path changes the corresponding item should be removed from memory and then added back with the new path index
- Each directory should have a clear single responsibility (data stores, UI components, form logic, etc.)

## Obsidian Plugin Guidelines Compliance

This plugin follows the [Obsidian Plugin Guidelines](https://docs.obsidian.md/Plugins/Releasing/Plugin+guidelines). Key standards:

### Security
- **Never use `innerHTML`, `outerHTML`, or `insertAdjacentHTML`** for user-generated content
- Use Obsidian's safe DOM helpers: `createEl()`, `createSpan()`, `createDiv()`, etc.
- Always construct DOM elements safely to prevent XSS vulnerabilities

### UI Text and Styling
- **Use sentence case** for all UI text (only first word and proper nouns capitalized)
- **Avoid HTML heading tags** (`<h1>`, `<h2>`, etc.) in settings - use `setHeading()` if headings are needed
- **Omit headings** for single-section settings tabs
- **Avoid "Settings" in headings** - context is already within settings

### Console Logging
- **Minimize console logging** - remove unnecessary `console.log`, `console.info`, `console.warn` statements
- **Keep only essential error logs** in catch blocks for debugging
- Clean developer console improves user experience

### Code Organization
- Use `this.app` instead of global `app` object for future compatibility
- Use `onLayoutReady()` to defer non-essential operations during plugin load
- Use `registerEvent()` and `addCommand()` for automatic resource cleanup

### Metadata and Licensing
- Ensure LICENSE file matches package.json license field
- Include proper author information in LICENSE, package.json, and manifest.json
- Provide descriptive manifest.json description for Community Plugins directory

## Documentation Maintenance

This repository follows a documentation structure aligned with user and developer needs:

### Documentation Structure

- **README.md** - User-focused documentation (installation, usage, features, troubleshooting)
- **devlog/** - Historical development decisions, considerations, and architectural choices
- **docs/** - Detailed development documentation (setup, architecture, contributing)

### When to Update Documentation

**Always update when:**
- Adding new features or functionality → Update README.md (Features/Usage sections) and create devlog entry
- Changing user-facing behavior → Update README.md (Usage/Configuration sections)
- Making architectural decisions → Create or update devlog entry
- Changing development setup → Update `docs/development.md`
- Modifying code structure → Update `docs/architecture.md` if significant

**Consider updating when:**
- Refactoring code → Update devlog if pattern changes significantly
- Fixing bugs → Update README troubleshooting if user-visible
- Adding new dependencies → Update `docs/development.md` prerequisites

### Documentation Update Guidelines

1. **README.md Updates:**
   - Keep user-focused (avoid development details)
   - Update Features section when adding capabilities
   - Update Usage/Configuration when behavior changes
   - Add troubleshooting entries for common issues
   - Keep installation instructions current

2. **Devlog Entries:**
   - Create new entry for significant architectural decisions
   - Include attribution section with developer name and AI model
   - Document context, considerations, and rationale
   - Include Decision Log section tracking all decisions with:
     - Decision description
     - Rationale
     - Attribution (User/AI Model)
     - Date
   - Include implementation details and future considerations
   - Use format: `YYYY-MM-DD-description.md`
   - Update `devlog/README.md` index when adding entries

3. **Docs Directory Updates:**
   - `docs/development.md` - Update when setup process changes
   - `docs/architecture.md` - Update when major structural changes occur
   - `docs/contributing.md` - Update when development patterns change
   - Keep documentation index (`docs/README.md`) current

4. **This File (.cursorrules):**
   - Update when patterns or conventions change
   - Document new architectural decisions that affect code style
   - Keep documentation maintenance section current

### Documentation Update Checklist

When making code changes, consider:
- [ ] Does this change user-visible behavior? → Update README.md
- [ ] Is this a significant architectural decision? → Create devlog entry
- [ ] Does this change how developers work? → Update docs/development.md
- [ ] Does this change code structure? → Update docs/architecture.md
- [ ] Does this introduce new patterns? → Update .cursorrules

**Note**: In a single-user environment, documentation can be updated iteratively. It's acceptable to make code changes first and update documentation in a follow-up, but documentation should not be neglected entirely.

